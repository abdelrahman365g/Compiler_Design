/*
 * JavaCC Options and setup for AST (JJTREE)
 */
options {
    STATIC = false;
    LOOKAHEAD = 1;
    CHOICE_AMBIGUITY_CHECK = 2;
    OTHER_AMBIGUITY_CHECK = 1;
    DEBUG_PARSER = false;
    DEBUG_TOKEN_MANAGER = false;
    DEBUG_LOOKAHEAD = false;
    FORCE_LA_CHECK = true;
    BUILD_PARSER = true;
    BUILD_TOKEN_MANAGER = true;
    UNICODE_INPUT = false;
    JAVA_UNICODE_ESCAPE = false;
    IGNORE_CASE = false;
    USER_TOKEN_MANAGER = false;
    USER_CHAR_STREAM = false;

    // Enable JJTree for Abstract Syntax Tree generation
    JJTREE_OUTPUT_DIRECTORY = "ast"; // Save generated AST nodes in a specific directory
    NODE_DEFAULT_VOID = true;
    MULTI = true;
    NODE_PREFIX = "AST";
}

PARSER_BEGIN(MyJavaParser)
package ast;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;

// Placeholder for custom SymbolTable and SemanticChecker classes
// IMPORTANT: You MUST create these classes in your Java project.
class SymbolTable {
    // Methods for pushScope, popScope, enterSymbol, checkType, checkRedeclaration, checkUnused
}
class SemanticChecker {
    // Methods for type checking expressions and statements
}

public class MyJavaParser {
    // 1. Symbol Table instance (for semantic checks)
    private static SymbolTable globalScope = new SymbolTable();
    private static SymbolTable currentScope = globalScope;

    public static void main(String args[]) throws ParseException, java.io.IOException {
        InputStream input = (args.length > 0) ? new java.io.FileInputStream(args[0]) : System.in;
        MyJavaParser parser = new MyJavaParser(input);
        
        try {
            ASTProgram root = parser.Program();
            System.out.println("Syntax validation successful.");
            
            // 2. Output Symbol Table (Required in specs)
            System.out.println("\n--- Symbol Table ---");
            // Logic to print all collected symbols from globalScope
            
            // 3. Output AST (Required in specs)
            System.out.println("\n--- Abstract Syntax Tree (AST) ---");
            // Use the AST Print/Traverse method (e.g., root.dump(""))
            root.dump(""); 

            // 4. Perform Semantic Checks (Bonus feature)
            System.out.println("\n--- Semantic Analysis (Bonus) ---");
            // Implement and run SemanticChecker on the AST
            
        } catch (ParseException e) {
            // 5. Detailed Error Reporting (Required in specs)
            System.err.println("Syntax Error: " + e.getMessage());
        }
    }
}

PARSER_END(MyJavaParser)

/* ------------------ LEXICAL ANALYSIS (Phase 1) ------------------ */

// SKIP Rules for Whitespace and Comments (Implemented and correct)
SKIP : {
    " " | "\t" | "\n" | "\r"
  | < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
  | < "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" >
}

// TOKEN Definitions (Keywords, Literals, Operators)
TOKEN : {
    < CLASS: "class" >
  | < INT: "int" >
  | < BOOL: "bool" >
  | < STRING: "string" >
  | < FUNC : "function" >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < SEMI: ";" >
  | < COMMA: "," >
  | < IF: "if" >
  | < ELSE: "else" >
  | < WHILE: "while" >
  | < FOR: "for" >
  | < RETURN: "return" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < ASSIGN: "=" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < MUL: "*" >
  | < DIV: "/" >
  | < EQ: "==" >
  | < NE: "!=" >
  | < ST: "<" >
  | < GT: ">" >
  | < SE: "<=" >
  | < GE: ">=" >
  | < AND: "&&" >
  | < OR: "||" >
  | < NOT: "!" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  // Added tokens for Update Expression in For loop
  | < PLUS_PLUS: "++" >
  | < MINUS_MINUS: "--" >

  | < NUMBER: (["0"-"9"])+ ("." (["0"-"9"])+)? >
  | < STRING_LITERAL: "\"" (~["\"","\\"] | "\\" (~[]))* "\"" >
  | < IDENTIFIER: ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9","_"])* >
}
/* ------------------ PARSER GRAMMAR (FIXED) ------------------ */

// 1. Program
ASTProgram Program() #Program: {} {
    ( ClassDeclaration() )*
    <EOF>
    { return (ASTProgram) jjtThis; }
}

// 2. Class Declaration
void ClassDeclaration() #ClassDeclaration: { Token t = null; } {
    <CLASS> t = <IDENTIFIER> 
    <LBRACE> ( FunctionDeclaration() )* <RBRACE>
}

// 3. Function Declaration
void FunctionDeclaration() #FunctionDeclaration: { Token t = null; } {
    <FUNC> Type() t = <IDENTIFIER> 
    <LPAREN> Parameters() <RPAREN>
    <LBRACE> FunctionBody() <RBRACE>
}

// 4. Function Parameters
void Parameters() #Parameters: {} {
    ( Type() <IDENTIFIER> ( <COMMA> Type() <IDENTIFIER> )* )?
}

// 5. Function Body
void FunctionBody() #FunctionBody: {} {
    ( Statement() )*
}

// 6. Type Definition
void Type() #Type: { Token t = null; } {
    ( t = <INT> | t = <BOOL> | t = <STRING> )
    { jjtThis.setName(t.image); }
}

// 7. Statements
void Statement() : {} {
    ( LOOKAHEAD(2) VarDeclaration() | Assignment() | IfStatement() | WhileStatement() | ForStatement() | ReturnStatement() )
}

// 8. Variable Declaration
void VarDeclaration() #VarDeclaration: { Token t = null; } {
    Type() t = <IDENTIFIER> 
    ( <ASSIGN> AssignmentExpression() #VarAssignment(2) )? 
    <SEMI> 
}

// 9. Return Statement
void ReturnStatement() #ReturnStatement: {} {
    <RETURN> AssignmentExpression() <SEMI>
}

// 10. Assignment Statement
void Assignment() #Assignment: { Token t = null; } {
    t = <IDENTIFIER> <ASSIGN> AssignmentExpression() <SEMI> 
}

// 11. If Statement
void IfStatement() #IfStatement: {} {
    <IF> <LPAREN> BooleanExpression() <RPAREN> 
    <LBRACE> ( Statement() )* <RBRACE> 
    ( ElseStatement() )?
}

// 12. Else Statement
void ElseStatement() #ElseStatement: {} {
    <ELSE> <LBRACE> ( Statement() )* <RBRACE>
}

// 13. While Statement
void WhileStatement() #WhileStatement: {} {
    <WHILE> <LPAREN> BooleanExpression() <RPAREN> 
    <LBRACE> ( Statement() )* <RBRACE>
}

// 14. For Statement (FIXED SEMICOLON ISSUE)
void ForStatement() #ForStatement: {} {
    <FOR> <LPAREN>
    // ForInit consumes the semicolon inside VarDeclaration/Assignment
    ( ForInit() )? 
    // If ForInit is empty, we expect a semicolon. If not, ForInit already ate it.
    // This logic is tricky in JavaCC. 
    // BETTER FIX: Let's assume ForInit includes the semi-colon.
    // If ForInit is missing, we need a literal SEMI.
    ( BooleanExpression() )? <SEMI>
    ( UpdateExpression() )?
    <RPAREN> 
    <LBRACE> ( Statement() )* <RBRACE>
}

// Helper Rule for For loop initialization
void ForInit() #ForInit : {} {
    ( VarDeclaration() | Assignment() ) 
}

// Helper Rule for For loop update expression (FIXED NODE ARITY)
// Helper Rule for For loop update expression
void UpdateExpression() #UpdateExpression : { Token t = null; } {
    // 1. لازم نحول الـ Identifier لـ Node عشان يبقى موجود في الـ Stack
    ( t = <IDENTIFIER> #Identifier ) 
    
    ( 
        // دلوقتي الـ Stack فيه [Identifier]
        // الـ Assignment(2) هتسحب الـ Expression والـ Identifier
        <ASSIGN> AssignmentExpression() #Assignment(2) 
      | 
        // الـ Increment(1) هتسحب الـ Identifier بس
        <PLUS_PLUS> #Increment(1) 
      | 
        // الـ Decrement(1) هتسحب الـ Identifier بس
        <MINUS_MINUS> #Decrement(1) 
    )
}

// 15. Expressions
void AssignmentExpression() #AssignmentExpression: {} {
    BooleanExpression()
}

// 16. Boolean Expression
void BooleanExpression() #BooleanExpression(>1): {} {
    ConditionalExpression() ( ( <AND> | <OR> ) ConditionalExpression() )*
}

// 17. Conditional Expression
void ConditionalExpression() #ConditionalExpression(>1): {} {
    RelationalExpression() ( ( <EQ> | <NE> ) RelationalExpression() )*
}

// 18. Relational Expression
void RelationalExpression() #RelationalExpression(>1): {} {
    AdditiveExpression() ( ( <ST> | <GT> | <SE> | <GE> ) AdditiveExpression() )*
}

// 19. Additive Expression (FIXED CRASH HERE)
void AdditiveExpression() #AdditiveExpression(>1): {} {
    Term() 
    ( 
       ( <PLUS> Term() #Add(2) ) 
     | ( <MINUS> Term() #Subtract(2) ) 
    )*
}

// 20. Term (FIXED CRASH HERE)
void Term() #Term(>1): {} {
    Factor() 
    ( 
       ( <MUL> Factor() #Multiply(2) ) 
     | ( <DIV> Factor() #Divide(2) ) 
    )*
}

// 21. Factor
void Factor() #Factor: { Token t = null; } {
    ( t = <NUMBER> #NumberLiteral 
    | t = <IDENTIFIER> #Identifier 
    | t = <STRING_LITERAL> #StringLiteral 
    | <TRUE> #BooleanTrue 
    | <FALSE> #BooleanFalse 
    )
    { 
       if (t != null) jjtThis.value = t.image; // Useful to store value
    }
    | <LPAREN> AssignmentExpression() <RPAREN>
}

// 22. Class Body (Handles methods and fields, though fields are not in the test file)
void ClassBody() #ClassBody: {} {
    ( FunctionDeclaration() )*
    // ( FieldDeclaration() )* // If you want to support class fields
}